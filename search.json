[{"title":"JDK源码阅读笔记——集合Ⅰ数组ArrayList","url":"/2020/04/06/JDK源码阅读笔记——集合I数组ArrayList/","content":"\n> 本JDK源码阅读笔记基于OpenJDK 13 : <https://github.com/openjdk/jdk>\n>\n> 一些可能表述或理解不当，请见谅\n\n## 0.前言\n\n之前跟着[芋道源码](http://www.iocoder.cn/ )的**精尽 JDK 源码解析**看了一遍，过了一个月后发现不做笔记不复习基本都忘光了，于是萌生了搭建一个博客来记录一下笔记，当是给自己挖一个坑吧。\n\n## 1.概述\n\n**ArrayList**  是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。\n\n## 2.类图\n\nArrayList 实现的接口、继承的抽象类，如下图所示：\n\n![ArrayList.jpg](https://i.loli.net/2020/04/06/sczg7m2PW6iIhdn.jpg)\n\n- **java.util.AbstractList**  提供了 List 接口的骨架实现，大幅度的减少了实现**迭代遍历**相关操作的代码。如  ==#iterator()= 、 ==#indexOf(Object o)== 等方法\n- **java.util.List** 提供数组的添加、删除、修改、迭代遍历等操作\n- **java.util.RandomAccess** 表示 ArrayList 里的元素可以被高效的随机访问，以下标数字的方式获取元素\n- **java.io.Serialiable** 表示 ArrayList 支持序列化和反序列化操作，具有固定的 serialVersionUID 属性值 \n- **java.lang.Cloneable** 表示 ArrayList 支持调用 Object 的 ==#clone()== 方法实现拷贝\n\n## 3.属性\n\nArrayList 的属性只有两个：\n\n![02.png](https://i.loli.net/2020/04/06/wGp4x5s7bC2RQdF.png)\n\n- **elementData** 元素数组\n\n- **size** 数组大小。 **size** 代表 ArrayList 已经使用 elementData 的元素的数量，调用 ==#size()== 方法也是返回该属性大小。并且，当添加新的元素时，恰好其就是元素添加到数组的下标。然而， ArrayList 真正的大小是 **elementData** 的大小。\n\n源码如下：\n\n```java\n   /**\n     *\n     * 元素数组\n     *\n     * 当添加新的元素时，如果该数组容量不足，会创建新数组，并将原数组的元素拷贝到新数组。\n     * 之后，将该变量的内存地址指向该新数组。\n     *\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     *\n     * 已使用的数组的大小\n     *\n     * The size of the ArrayList (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n```\n\n\n## 4.构造方法\n\nArrayList一共有3个构造方法\n\n1. **==#ArrayList(int initialCapacity)==**\n\n根据传入的容量来创建数组，合理使用避免扩容\n```java\n    public ArrayList(int initialCapacity) {\n        // 初始化容量大于0时, 创建Object数组\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        // 初始化容量等于0时, 指向 EMPTY_ELEMENTDATA 对象\n        // 添加元素时, 会进行扩容创建需要的数组\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        // 初始化容量小于0时, 抛出异常\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n\n2. **==#ArrayList()==**\n\n无参默认构造函数\n\n```java\n/**\n * 无参数构造\n *\n * Constructs an empty list with an initial capacity of ten.\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n3. **==#ArrayList(Collection<? extends E> c)==**\n\n传入 **c** 集合，作为 ArrayList 的 **elementData** 进行初始化\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n    // 将c转换为Object数组\n    elementData = c.toArray();\n    // 如果数组长度大于0\n    if ((size = elementData.length) != 0) {\n        // defend against c.toArray (incorrectly) not returning Object[]\n        // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)\n        // 如果集合元素不是Object[]类型, 则会创建新的Object[], 并将elementData赋值到其中, 最后赋值给elementData\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    // 如果数组长度等于0, 则使用EMPTY_ELEMENTDATA\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n- 附： ArrayList 的三个**常量**\n\n```java\n/**\n * 默认初始化容量\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n/**\n *\n * 共享的空数组对象\n *\n * 在{@link #ArrayList(int)} 或 {@link #ArrayList(Collection)} 构造方法中，\n * 如果传入的初始化大小或者集合大小为0时，将{@link #elementData}指向它\n */\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n/**\n * 共享的空数组对象, 用于{@link #ArrayList()} 构造方法.\n *\n * 通过使用该静态变量, 和{@link #EMPTY_ELEMENTDATA}在第一次添加元素时区分开来\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n- 一般认为在初始化不指定容量时，ArrayList的默认大小为 10 。但实际上是初始化为 ==DEFAULTCAPACITY_EMPTY_ELEMENTDATA== 这个空数组，原因是考虑到部分场景下， ArrayList 被初始化而实际并未使用。所以，ArrayList初始化时是个空数组，只有添加元素后，才会扩容为容量 10 的数组。\n\n-  ==DEFAULTCAPACITY_EMPTY_ELEMENTDATA== 首次扩容 10 ，而 ==EMPTY_ELEMENTDATA== 按照 1.5 倍扩容\n\n## 5.添加元素与扩容\n\n### 5.1.#add(E e)——添加单个元素\n\n  **顺序**添加元素到末尾，若容量不够会先进行扩容\n\n  ```java\n      public boolean add(E e) {\n          // 增加数组修改次数, 父类AbstractList上, 定义了modCount属性, 用于记录数组修改次数\n          modCount++;\n          // 添加元素\n          add(e, elementData, size);\n          // 返回添加成功\n          return true;\n      }\n  \n      private void add(E e, Object[] elementData, int s) {\n          // 如果容量不够, 进行扩容\n          if (s == elementData.length)\n              elementData = grow();\n          // 在数组末尾添加元素\n          elementData[s] = e;\n          // 数量加一\n          size = s + 1;\n      }\n  ```\n\n### 5.2.#add(int index, E element) ——插入单个元素到指定位置\n\n  将 index + 1 位置开始的元素往后挪 1 位，再把元素插入到指定位置\n\n  ```java\n      public void add(int index, E element) {\n          // 校验位置是否在数组范围内\n          rangeCheckForAdd(index);\n          // 增加数组修改次数\n          modCount++;\n          // 如果数组大小不足, 进行扩容\n          final int s;\n          Object[] elementData;\n          if ((s = size) == (elementData = this.elementData).length)\n              elementData = grow();\n          // 将index+1位置开始的元素往后挪\n          System.arraycopy(elementData, index,\n                           elementData, index + 1,\n                           s - index);\n          // 设置元素到指定的位置\n          elementData[index] = element;\n          // 数组大小加一\n          size = s + 1;\n      }\n  \n      private void rangeCheckForAdd(int index) {\n          if (index > size || index < 0)\n              throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n      }\n  ```\n\n  \n\n### 5.3.#grow()——数组扩容\n\n  当 elementData 容量不足时，会进行扩容。扩容首先创建一个新的更大的数组，一般是 **1.5** 倍大小，然后利用 ==**java.utils.Arrays#copyOf(T[], int)**== 拷贝原有的数组到新数组，返回新数组\n\n  ```java\n      private Object[] grow() {\n          // 最小需要扩容1\n          return grow(size + 1);\n      }\n  \n      private Object[] grow(int minCapacity) {\n          int oldCapacity = elementData.length;\n          // 如果原容量大于0, 或者数组不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA时, 计算新的数组大小, 并创建扩容\n          if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 计算新的数组大小\n              // 简单来说是Math.max(minGrowth, prefGrowth) + oldLength\n              // 一般情况下, 是1.5倍扩容(>> 1 为右移操作，相当于除以 2). 但是存在两个特殊情况:\n              // 1> 初始化数组要求大小为0时, 此时使用minCapacity传入的1\n              // 2> 添加多个元素时, 传入的minCapacity不再仅仅加1,\n              // 而是扩容到elementData恰好可以添加多个元素, 而该数量可能会超过当前size的1.5倍\n              int newCapacity = ArraysSupport.newLength(oldCapacity,\n                      minCapacity - oldCapacity, /* minimum growth */\n                      oldCapacity >> 1           /* preferred growth */);\n              return elementData = Arrays.copyOf(elementData, newCapacity);\n          // 如果是DEFAULTCAPACITY_EMPTY_ELEMENTDATA数组, 直接创建新的数组\n          } else {\n              return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n          }\n      }\n  ```\n\n### 5.4.#addAll(Collection<? extends E> c)——添加多个元素\n\n  在数组末尾批量添加多个元素，可以避免多次扩容\n\n  ```java\n      public boolean addAll(Collection<? extends E> c) {\n          // 转换成a数组\n          Object[] a = c.toArray();\n          // 增加修改次数\n          modCount++;\n          // 如果a数组大小为0, 返回ArrayList数组无变化\n          int numNew = a.length;\n          if (numNew == 0)\n              return false;\n          // 如果elementData数组剩余容量不足, 则进行扩容, 扩至能容纳a数组\n          Object[] elementData;\n          final int s;\n          if (numNew > (elementData = this.elementData).length - (s = size))\n              elementData = grow(s + numNew);\n          // 将a复制到elementData从s开始位置\n          System.arraycopy(a, 0, elementData, s, numNew);\n          // 数组大小加numNew\n          size = s + numNew;\n          return true;\n      }\n  ```\n\n### 5.5.#addAll(int index, Collection<? extends E> c)——从指定位置插入多个元素\n\n  从指定index位置插入多个元素，如果 index 开始的位置已经被占用，则把元素往后挪 c 的长度。 ***** 号位置是差异点\n\n  ```java\n      public boolean addAll(int index, Collection<? extends E> c) {\n          // 校验范围是否在数组内\n          rangeCheckForAdd(index);\n  \n          // 转换成a数组\n          Object[] a = c.toArray();\n          // 增加修改次数\n          modCount++;\n          // 如果a数组大小为0, 返回ArrayList数组无变化\n          int numNew = a.length;\n          if (numNew == 0)\n              return false;\n          // 如果elementData数组剩余容量不足, 则进行扩容, 扩至能容纳a数组\n          Object[] elementData;\n          final int s;\n          if (numNew > (elementData = this.elementData).length - (s = size))\n              elementData = grow(s + numNew);\n  \n          // **如果index开始的位置已经被占用, 将它们后移\n          int numMoved = s - index;\n          if (numMoved > 0)\n              System.arraycopy(elementData, index,\n                               elementData, index + numNew,\n                               numMoved);\n          // 将a复制到elementData从s开始位置\n          System.arraycopy(a, 0, elementData, index, numNew);\n          // 数组大小加numNew\n          size = s + numNew;\n          return true;\n      }\n  ```\n\n### 5.6.#ensureCapacity(int minCapacity)——主动扩容\n\n```java\n    /**\n     *\n     * 保证elementData数组容量至少有minCapacity(主动扩容)\n     */\n    public void ensureCapacity(int minCapacity) {\n        if (minCapacity > elementData.length // 如果minCapacity大于数组的容量\n            && !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA // 如果elementData是DEFAULTCAPACITY_EMPTY_ELEMENTDATA的时候\n                 && minCapacity <= DEFAULT_CAPACITY)) { // 需要最低容量大于DEFAULT_CAPACITY, 因为实际上容量是DEFAULT_CAPACITY\n            // 数组修改次数加一\n            modCount++;\n            // 扩容\n            grow(minCapacity);\n        }\n    }\n```\n\n## 6. 移除元素与缩容\n\n### 6.1.#remove(int index)——移除单个元素\n\n移除指定位置的单个元素，并返回该元素\n\n```java\n    public E remove(int index) {\n        // 校验index不超过size\n        Objects.checkIndex(index, size);\n        final Object[] es = elementData;\n\n        // 记录该位置的原值\n        @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index];\n        // 快速移除\n        fastRemove(es, index);\n\n        // 返回该位置的原值\n        return oldValue;\n    }\n```\n\n### 6.2.#removeRange(int fromIndex, int toIndex)——移除指定区间元素\n\n移除指定区间内多个元素\n\n```java\n    protected void removeRange(int fromIndex, int toIndex) {\n        // 范围不正确, 抛出异常\n        if (fromIndex > toIndex) {\n            throw new IndexOutOfBoundsException(\n                    outOfBoundsMsg(fromIndex, toIndex));\n        }\n        // 修改次数加一\n        modCount++;\n        // 移除[fromIndex, toIndex)的多个元素\n        shiftTailOverGap(elementData, fromIndex, toIndex);\n    }\n\n    private void shiftTailOverGap(Object[] es, int lo, int hi) {\n        // 将es从hi位置开始的元素, 移到lo位置开始\n        System.arraycopy(es, hi, es, lo, size - hi);\n        // 将从[size - hi + lo, size)的元素置空, 因为已经被挪到前面了\n        // i = (size -= hi - lo)更新了size\n        for (int to = size, i = (size -= hi - lo); i < to; i++)\n            es[i] = null;\n    }\n```\n\n### 6.3.#removeAll(Collection<?> c)——移除指定多个元素\n\n```java\n/**\n * 批量移除多个指定元素\n * 通过两个变量w(写入位置)和r(读取位置), 按照r顺序遍历数组elementData\n * 如果不存在于指定的多个元素中, 则写入elementData的w位置, 然后w+1, 跳到下一个写入位置\n * 通过这样的方式, 实现将不存在elementData覆盖写到w位置\n */\npublic boolean removeAll(Collection<?> c) {\n    return batchRemove(c, false, 0, size);\n}\n\n/**\n * complement 参数，翻译过来是“补足”的意思。怎么理解呢？表示如果 elementData 元素在 c 集合中时，是否保留。\n * 如果 complement 为 false 时，表示在集合中，就不保留，这显然符合 #removeAll(Collection<?> c) 方法要移除的意图。\n * 如果 complement 为 true 时，表示在集合中，就暴露，这符合我们后面会看到的 #retainAll(Collection<?> c) 方法要求交集的意图。\n */\nboolean batchRemove(Collection<?> c, boolean complement,\n                    final int from, final int end) {\n    // 校验c非null\n    Objects.requireNonNull(c);\n    final Object[] es = elementData;\n    int r;\n    // Optimize for initial run of survivors\n    // 优化, 顺序遍历elementData数组, 找到第一个不符合complement, 然后结束遍历\n    for (r = from;; r++) {\n        // 遍历到尾, 都没有不符合条件的, 直接返回false\n        if (r == end)\n            return false;\n        // 如果包含结果不符合complement时, 结束\n        if (c.contains(es[r]) != complement)\n            break;\n    }\n    // 设置开始写入w为r, 注意不是r++\n    // r++后, 用于读取下一个位置的元素. 因为通过上面的优化, 我们已经知道es[r]是不符合条件的\n    int w = r++;\n    try {\n        // 继续遍历elementData数组, 如果符合条件, 则进行移除\n        for (Object e; r < end; r++)\n            if (c.contains(e = es[r]) == complement) // 判断符合条件\n                es[w++] = e; // 移除的方式, 通过将当前值e写入到w位置, 然后w跳到下一个位置\n    } catch (Throwable ex) {\n        // Preserve behavioral compatibility with AbstractCollection,\n        // even if c.contains() throws.\n        // 如果contains方法发生异常, 则将es从r位置的数组写入到es从w开始的位置\n        System.arraycopy(es, r, es, w, end - r);\n        w += end - r;\n        // 抛出异常\n        throw ex;\n    } finally {\n        // 增加数组修改次数\n        modCount += end - w;\n        // 将数组[w, end)位置赋值为null\n        shiftTailOverGap(es, w, end);\n    }\n    return true;\n}\n```\n\n### 6.4.retainAll(Collection<?> c)——求elementData与多个元素交集\n\n一样调用 batchRemove ，区别是传入 true ，即移除不在 c 的元素\n\n```java\npublic boolean retainAll(Collection<?> c) {\n    return batchRemove(c, true, 0, size);\n}\n```\n\n### 6.5.#trimToSize()——缩容\n\n建立与 elementData 同长度的数组，并进行复制\n\n```java\npublic void trimToSize() {\n    // 增加修改次数\n    modCount++;\n    // 如果有多余的空间, 则进行缩容\n    if (size < elementData.length) {\n        elementData = (size == 0)\n          ? EMPTY_ELEMENTDATA // 大小为0时, 直接使用EMPTY_ELEMENTDATA\n          : Arrays.copyOf(elementData, size); // 大小大于0时, 则创建大小为size的新数组, 将原数组复制到其中\n    }\n}\n```\n\n## 7.查找、获取与设定元素\n\n### 7.1.#indexOf(Object o)——查找元素\n\n从头开始遍历寻找目标元素\n\n```java\npublic int indexOf(Object o) {\n    return indexOfRange(o, 0, size);\n}\n\nint indexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    // o为null的情况\n    if (o == null) {\n        for (int i = start; i < end; i++) {\n            if (es[i] == null) {\n                return i;\n            }\n        }\n    // o非null的情况\n    } else {\n        for (int i = start; i < end; i++) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    // 找不到返回-1\n    return -1;\n}\n```\n\n### 7.2.#contains(Object o)——判断是否包含该元素\n\n用上述的<u>#indexOf(Object o)</u>方法实现\n\n```java\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n```\n\n### 7.3.#lastIndexOf(Object o)——查找最后一个指定元素的位置\n\n和 ==#indexOf(Object o)== 差不多，就是倒序遍历\n\n```java\npublic int lastIndexOf(Object o) {\n    return lastIndexOfRange(o, 0, size);\n}\n\nint lastIndexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    // o为null的情况\n    if (o == null) {\n        for (int i = end - 1; i >= start; i--) {\n            if (es[i] == null) {\n                return i;\n            }\n        }\n    // o非null的情况\n    } else {\n        for (int i = end - 1; i >= start; i--) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    // 找不到返回-1\n    return -1;\n}\n```\n\n### 7.4.#get(int index)——获取指定位置元素\n\n```java\npublic E get(int index) {\n    // 校验index不超过size\n    Objects.checkIndex(index, size);\n    // 获得index位置的元素--时间复杂度为O(1)\n    return elementData(index);\n}\n```\n\n### 7.5. #set(int index, E element)——在指定位置设定元素\n\n```java\npublic E set(int index, E element) {\n    // 校验index不超过size\n    Objects.checkIndex(index, size);\n    // 获得index位置原来的值\n    E oldValue = elementData(index);\n    // 修改index位置为新值\n    elementData[index] = element;\n    // 返回旧值\n    return oldValue;\n}\n```\n\n## 8.序列化与反序列化\n\n### 8.1.#writeObject(java.io.ObjectOutputStream s)——序列化\n\n elementData 带有关键字 transient ，通常来说不会被序列化。\n\n ArrayList 的序列化是先写入非静态、非 transient 属性，然后再遍历写入 elementData 数据，节省空间和时间\n\n```java\n/**\n *\n * 实现ArrayList数组的序列化\n *\n */\n@java.io.Serial\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException {\n    // Write out element count, and any hidden stuff\n    // 获得当前数组的修改次数\n    int expectedModCount = modCount;\n    // 写入非静态属性, 非transient属性\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioral compatibility with clone()\n    // 写入size, 主要为了与clone方法兼容\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    // 逐个写入elementData数组的元素\n    // elementData是transient定义的, 并不一定全满, 容量有一定的预留\n    // 直接序列化, 会造成空间的浪费, 所以只序列化[0, size)的元素\n    for (int i=0; i<size; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    // 如果数组修改次数发生了变化, 抛出异常\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n```\n\n### 8.2.#readObject(java.io.ObjectInputStream s)——反序列化\n\n反序列化也是一样，先读取非静态、非 transient 属性，然后再逐个读取元素\n\n```java\n@java.io.Serial\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n\n    // Read in size, and any hidden stuff\n    // 读取非静态、非transient属性\n    s.defaultReadObject();\n\n    // Read in capacity\n    // 读取size, 不过忽略不用\n    s.readInt(); // ignored\n\n    if (size > 0) {\n        // like clone(), allocate array based upon size not capacity\n        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);\n        // 创建elements数组\n        Object[] elements = new Object[size];\n\n        // Read in all elements in the proper order.\n        // 逐个读取\n        for (int i = 0; i < size; i++) {\n            elements[i] = s.readObject();\n        }\n\n        // 赋值给elementData\n        elementData = elements;\n    } else if (size == 0) {\n        // 如果size是0, 直接使用空数组\n        elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new java.io.InvalidObjectException(\"Invalid size: \" + size);\n    }\n}\n```\n\n## 99.其他常用方法\n\n### 99.1.#toArray()——转换为数组\n\nArrayList 提供两个方法用于把 List 转换为数组\n\n1. 直接返回 Object 数组\n\n\n```java\npublic Object[] toArray() {\n    return Arrays.copyOf(elementData, size);\n}    \n```\n\n2. 转换成指定类型数组\n\n```java\n@SuppressWarnings(\"unchecked\")\npublic <T> T[] toArray(T[] a) {\n    // 如果传入的数组小于size大小, 则直接复制一个新数组返回\n    if (a.length < size)\n        // Make a new array of a's runtime type, but my contents:\n        return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n    // 将elementData复制到a中\n    System.arraycopy(elementData, 0, a, 0, size);\n    // 如果传入的数组长度大于size, 则将a[size]赋值为null\n    if (a.length > size)\n        a[size] = null;\n    // 返回a\n    return a;\n}\n```\n\n### 99.2.#hashCode()——求哈希值\n\n```java\npublic int hashCode() {\n    // 获取当前数组修改次数\n    int expectedModCount = modCount;\n    // 计算哈希值\n    int hash = hashCodeRange(0, size);\n    // 如果修改次数发生改变, 则抛出ConcurrentModificationException异常\n    checkForComodification(expectedModCount);\n    return hash;\n}\n\nint hashCodeRange(int from, int to) {\n    final Object[] es = elementData;\n    // 如果to超过大小, 则抛出异常\n    if (to > es.length) {\n        throw new ConcurrentModificationException();\n    }\n    // 遍历每个元素, *31求哈希值\n    int hashCode = 1;\n    for (int i = from; i < to; i++) {\n        Object e = es[i];\n        hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n    }\n    return hashCode;\n}\n```\n\n### 99.3.#equals(Object o)——判断相等\n\n```java\npublic boolean equals(Object o) {\n    // 如果是自己, 直接返回true\n    if (o == this) {\n        return true;\n    }\n\n    // 如果不是List类型, 直接返回false\n    if (!(o instanceof List)) {\n        return false;\n    }\n\n    final int expectedModCount = modCount;\n    // ArrayList can be subclassed and given arbitrary behavior, but we can\n    // still deal with the common case where o is ArrayList precisely\n    // 根据不同类型, 调用不同比对的方法.\n    // 主要考虑ArrayList可以直接使用其elementData属性, 性能更优\n    boolean equal = (o.getClass() == ArrayList.class)\n        ? equalsArrayList((ArrayList<?>) o)\n        : equalsRange((List<?>) o, 0, size);\n\n    // 如果修改次数发生改变, 则抛出ConcurrentModificationException异常\n    checkForComodification(expectedModCount);\n    return equal;\n}\n\nboolean equalsRange(List<?> other, int from, int to) {\n    // 如果to大于es的大小, 说明数组发生改变, 抛出异常\n    final Object[] es = elementData;\n    if (to > es.length) {\n        throw new ConcurrentModificationException();\n    }\n    // 通过迭代器遍历other, 然后逐个元素对比\n    var oit = other.iterator();\n    for (; from < to; from++) {\n        // 如果oit没有下一个, 或者元素不相等, 返回false不匹配\n        if (!oit.hasNext() || !Objects.equals(es[from], oit.next())) {\n            return false;\n        }\n    }\n    // 通过oit是否遍历完, 实现大小是否相等效果\n    return !oit.hasNext();\n}\n\nprivate boolean equalsArrayList(ArrayList<?> other) {\n    // 获得other数组的修改次数\n    final int otherModCount = other.modCount;\n    final int s = size;\n    boolean equal;\n    // 判断数组大小是否相等\n    if (equal = (s == other.size)) {\n        final Object[] otherEs = other.elementData;\n        final Object[] es = elementData;\n        // 如果s大于es或者otherEs的长度, 说明发生变化, 抛出异常\n        if (s > es.length || s > otherEs.length) {\n            throw new ConcurrentModificationException();\n        }\n        // 遍历, 逐个比较每个元素是否相等\n        for (int i = 0; i < s; i++) {\n            if (!Objects.equals(es[i], otherEs[i])) {\n                equal = false;\n                break; // 如果不相等, break\n            }\n        }\n    }\n    // 如果other修改次数发生变化, 则抛出ConcurrentModificationException异常\n    other.checkForComodification(otherModCount);\n    return equal;\n}\n```\n\n### 99.4.#clear()——清空数组\n\n```java\npublic void clear() {\n    // 增加数组修改次数\n    modCount++;\n    // 遍历数组, 倒序设置为null\n    final Object[] es = elementData;\n    for (int to = size, i = size = 0; i < to; i++)\n        es[i] = null;\n}\n```\n\n### 99.5.#clone()——克隆\n\n```java\npublic Object clone() {\n    try {\n        // 调用父类, 进行克隆\n        ArrayList<?> v = (ArrayList<?>) super.clone();\n        // 拷贝一个新的数组\n        v.elementData = Arrays.copyOf(elementData, size);\n        // 设置新数组修改次数为0\n        v.modCount = 0;\n        return v;\n    } catch (CloneNotSupportedException e) {\n        // this shouldn't happen, since we are Cloneable\n        throw new InternalError(e);\n    }\n}\n```\n\n### 99.6.#subList(int fromIndex, int toIndex)——创建子数组\n\n```java\n/**\n * SubList 不是一个只读数组，而是和根数组 root 共享相同的 elementData 数组，\n * 只是说限制了 [fromIndex, toIndex) 的范围\n *\n */\npublic List<E> subList(int fromIndex, int toIndex) {\n    subListRangeCheck(fromIndex, toIndex, size);\n    return new SubList<>(this, fromIndex, toIndex);\n}\n\nprivate static class SubList<E> extends AbstractList<E> implements RandomAccess {\n    /**\n     * 根ArrayList\n     */\n    private final ArrayList<E> root;\n    /**\n     * 父SubList\n     */\n    private final SubList<E> parent;\n    /**\n     * 起始位置\n     */\n    private final int offset;\n    /**\n     * 大小\n     */\n    private int size;\n    \n    //.......略\n```","tags":["jdk"]},{"title":"心血来潮的博客","url":"/2020/04/03/心血来潮的博客/","content":"\n突然觉得还是搭一个Blog来记录和总结一下看过的学过的东西，或许也坚持不了多久。\n\n<p align=\"right\">04.03.2020</p>","tags":["life"]}]