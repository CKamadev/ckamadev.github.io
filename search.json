[{"title":"JDK源码阅读笔记——集合Ⅱ链表LinkedList","url":"/2020/04/07/JDK源码阅读笔记——集合Ⅱ链表LinkedList/","content":"\n> 本JDK源码阅读笔记基于OpenJDK 13 : <https://github.com/openjdk/jdk>\n>\n> 一些可能表述或理解不当，请见谅\n\n## 1.概述\n\n**LinkedList** 是一个双向链表。它也可以当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随即插入、随机删除效率高。\n\n## 2.类图\n\nLinkedList 实现的接口、继承的抽象类，如下图所示：\n\n![01.jpg](https://i.loli.net/2020/04/07/jHa3urCQoOxZicG.png)\n\n与ArrayList一致的接口：\n\n- **java.util.List**\n- **java.io.Serialiable**\n- **java.lang.Cloneable**\n\n与ArrayList相比缺少的接口：\n- **java.util.RandomAccess** 即不支持随机访问\n\n除此之外还实现了：\n\n- **java.util.Deque** 提供**双端**队列功能，LinkedList 支持快速的在头尾添加元素和读取元素，所以容易实现该特性\n- **java.util.AbstractSequentialList** \n\n## 3.属性\n\n![LinkedListVsArray.png](https://i.loli.net/2020/04/07/gpLjv1alfo8bczZ.png)\n\n**LinkedList** 一共有3个属性\n\n- ```Node``` 类就是代表双端链表的节点 Node 。这个类的三个属性分别是当前节点、前一个节点、后一个节点。\n- ```first``` 和 ```last``` 属性分别代表链表的头节点和尾节点\n- ```size``` 属性表示链表的节点数量\n\n```java\n    /**\n     * 链表大小\n     */\n    transient int size = 0;\n\n    /**\n     *\n     * 头节点\n     *\n     * Pointer to first node.\n     */\n    transient Node<E> first;\n\n    /**\n     *\n     * 尾节点\n     *\n     * Pointer to last node.\n     */\n    transient Node<E> last;\n    /**\n     *\n     * 节点\n     *\n     * @param <E> 元素泛型\n     */\n    private static class Node<E> {\n        /**\n         * 元素\n         */\n        E item;\n        /**\n         * 前一个节点\n         */\n        Node<E> next;\n        /**\n         * 后一个节点\n         */\n        Node<E> prev;\n\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n```\n\n## 4.构造方法\n\n**无参构造方法**\n\n```java\npublic LinkedList() {\n}\n```\n\n**用已有的集合创建链表的构造方法**\n\n```java\npublic LinkedList(Collection<? extends E> c) {\n    this();\n    // 添加c到链表中\n    addAll(c);\n}\n```\n\n## 5.添加元素\n\n### 5.1.添加单个元素\n\n```#add(E e)```  默认插入到末尾\n\n```java\npublic boolean add(E e) {\n    // 添加末尾\n    linkLast(e);\n    return true;\n}\n\nvoid linkLast(E e) {\n    // <1>记录原last节点\n    final Node<E> l = last;\n    // <2>创建新节点\n    // 第一个参数表示, newNode的前一个节点为l\n    // 第二个参数表示, e为元素\n    // 第三个参数表示, newNode的后一个节点为null\n    final Node<E> newNode = new Node<>(l, e, null);\n    // <3>last指向新节点\n    last = newNode;\n    // <4>如果原last为null, 说明first也为空, 则first也指向新节点\n    if (l == null)\n        first = newNode;\n    // <5>如果原last非null, 说明first也非空, 则原last的next指向新节点\n    else\n        l.next = newNode;\n    // <6>增加链表大小\n    size++;\n    // <7>增加修改次数\n    modCount++;\n}\n```\n\n### 5.2.添加单个元素到指定位置\n\n```#add(int index, E element)```  如果指定的位置就是size，直接添加到末尾；否则，获取指定位置的元素，并把元素添加到该元素前\n\n```java\n/**\n *\n * 插入元素到指定位置\n *\n */\npublic void add(int index, E element) {\n    // 校验不要超过范围\n    checkPositionIndex(index);\n\n    // 如果刚好等于链表大小, 直接添加到尾部即可\n    if (index == size)\n        linkLast(element);\n    // 添加到第index的节点前面\n    else\n        linkBefore(element, node(index)); // 获得第index位置的Node节点node\n}\n\n/**\n  *\n  * 获得第index位置的Node节点node\n  *\n  */\nNode<E> node(int index) {\n    // assert isElementIndex(index);\n\n    // 如果index小于size的一半, 就正序遍历, 获得第index个节点\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n        // 如果index大于size的一半, 就倒序遍历, 获得第index个节点\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n\nvoid linkBefore(E e, Node<E> succ) {\n    // assert succ != null;\n    // 获得succ的前一个节点\n    final Node<E> pred = succ.prev;\n    // 创建新的节点newNode\n    final Node<E> newNode = new Node<>(pred, e, succ);\n    // 设置succ的前一个节点为新节点\n    succ.prev = newNode;\n    // 如果pred为null, 说明first也为空, 则first指向newNode\n    if (pred == null)\n        first = newNode;\n    // 如果pred非null, 说明first也非空, 则pred也指向newNode\n    else\n        pred.next = newNode;\n    // 增加链表大小\n    size++;\n    // 增加修改次数\n    modCount++;\n}\n```\n\n### 5.3.添加单个元素到链表的头尾\n\n由于LinkedList实现了Deque接口，所以实现了```#offerFirst(E e)```和```#offerLast(E e)```方法，分别添加元素到链表头尾\n\n```java\npublic boolean offerFirst(E e) {\n    addFirst(e);\n    return true;\n}\n\npublic boolean offerLast(E e) {\n    addLast(e);\n    return true;\n}\n\npublic void addFirst(E e) {\n\tlinkFirst(e);\n}\n\npublic void addLast(E e) {\n    // 与上面的linkLast一样\n\tlinkLast(e);\n}\n```\n\n```java\nprivate void linkFirst(E e) {\n    // 记录原first节点\n    final Node<E> f = first;\n    // 创建新节点\n    final Node<E> newNode = new Node<>(null, e, f);\n    // first指向新节点\n    first = newNode;\n    // 如果原first为空, 说明last也为空, 则last也指向新节点\n    if (f == null)\n        last = newNode;\n    // 如果原first非空, 说明last也非空, 则原first的next指向新节点\n    else\n        f.prev = newNode;\n    // 增加链表大小\n    size++;\n    // 增加数组修改次数\n    modCount++;\n}\n```\n\n### 5.4.添加多个元素\n\n```#addAll(Collection<? extends E> c)``` 将集合从指定位置开始插入\n\n```java\npublic boolean addAll(Collection<? extends E> c) {\n    return addAll(size, c);\n}\n\npublic boolean addAll(int index, Collection<? extends E> c) {\n    // 检查index范围\n    checkPositionIndex(index);\n\n    // 将c集合转换为数组\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    if (numNew == 0) // 如果无添加元素, 直接返回false\n        return false;\n\n    // 获取第index位置的节点succ和前驱节点pred\n    Node<E> pred, succ;\n    if (index == size) { // 如果index就是size, 说明插入到队尾, 所以succ为null, pred为last\n        succ = null;\n        pred = last;\n    } else { // 否则, succ是第index个节点, prev就是succ的前一个节点\n        succ = node(index);\n        pred = succ.prev;\n    }\n\n    // 遍历数组a, 将数据插入\n    for (Object o : a) {\n        @SuppressWarnings(\"unchecked\") E e = (E) o;\n        // 创建新节点\n        Node<E> newNode = new Node<>(pred, e, null);\n        // 如果pred是null, 插入到头部位置\n        if (pred == null)\n            first = newNode;\n        else\n            pred.next = newNode;\n        pred = newNode;\n    }\n\n    // 修改succ和pred的指向\n    if (succ == null) { // 如果 succ 为 null , 说明插入队尾, 则直接修改 last 指向最后一个 pred\n        last = pred;\n    } else { // 如果 succ 非 null, 说明插入到 succ 的前面\n        pred.next = succ;\n        succ.prev = pred;\n    }\n\n    // 增加链表大小\n    size += numNew;\n    // 增加数组修改次数\n    modCount++;\n    return true;\n}\n```\n\n## 6.移除元素\n\n### 6.1.移除指定位置的元素\n\n```#remove(int index)``` 找到第index个元素，调用```#unlink(Node<E> x)```方法进行移除\n\n```java\npublic E remove(int index) {\n    checkElementIndex(index);\n    // 获得第index的Node节点, 然后进行移除\n    return unlink(node(index)); // node()获得第index的node节点\n}\n\nE unlink(Node<E> x) {\n    // assert x != null;\n    // 获得x的前后节点 prev,next\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    // 将prev的next指向下一个节点\n    if (prev == null) { // 如果prev为空, 说明first被移除, 则直接将first指向next\n    first = next;\n    } else { // 如果prev非空\n    prev.next = next; // prev的next指向next\n    x.prev = null; // x的prev指向null\n    }\n\n    // 将next的prev指向上一个节点\n    if (next == null) { // 如果next为空, 说明last被移除, 则直接将last指向prev\n    last = prev;\n    } else { // 如果next非空\n    next.prev = prev; // next的prev指向prev\n    x.next = null; // x的next指向null\n    }\n\n    // 将x的item设置为null, 帮助GC\n    x.item = null;\n    // 减少链表大小\n    size--;\n    // 增加数组修改次数\n    modCount++;\n    return element;\n}\n```\n\n### 6.2.移除指定元素\n\n```#remove(Object o)``` 移除首个为 o 的元素，首先找到首个与 o 相等的节点，再调用```#unlink(Node<E> x)```进行移除\n\n```java\npublic boolean remove(Object o) {\n    if (o == null) { // o为null的情况\n        // 顺序遍历, 找到null的元素后, 进行移除\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        // 顺序遍历, 找到等于o的元素后, 进行移除\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n### 6.3.移除首个元素\n\n```#remove()``` 和 ```#removeFirst()``` 方法\n\n```java\npublic E remove() {\n    return removeFirst();\n}\n\npublic E removeFirst() {\n    final Node<E> f = first;\n    // 如果链表为空, 抛出异常\n    if (f == null)\n    throw new N\toSuchElementException();\n    // 移除链表首个元素\n    return unlinkFirst(f);\n}\n\nprivate E unlinkFirst(Node<E> f) {\n    // assert f == first && f != null;\n    final E element = f.item;\n    // 获得f的下一个节点\n    final Node<E> next = f.next;\n    // 设置f的item为null, 帮助GC\n    f.item = null;\n    // 设置f的next为null, 帮助GC\n    f.next = null; // help GC\n    // 修改first指向next\n    first = next;\n    // 修改next节点的prev指向null\n    if (next == null) // 如果链表只有一个元素, 说明被移除后, 队列就是空的, 则last设置为null\n        last = null;\n    else\n        next.prev = null;\n    // 链表大小减一\n    size--;\n    // 增加数组修改次数\n    modCount++;\n    return element;\n}\n```\n\n另外还有实现Queue接口的几个方法\n\n```java\npublic E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n\npublic E pop() {\n    return removeFirst();\n}\n\npublic E pollFirst() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n```\n\n### 6.4.移除最后一个元素\n\n```#removeLast()``` 方法\n\n```java\npublic E removeLast() {\n    final Node<E> l = last;\n    // 如果链表为空, 则抛出异常\n    if (l == null)\n        throw new NoSuchElementException();\n    // 移除链表的最后一个元素\n    return unlinkLast(l);\n}\n\nprivate E unlinkLast(Node<E> l) {\n    // assert l == last && l != null;\n    final E element = l.item;\n    // 获得f的上一个节点\n    final Node<E> prev = l.prev;\n    // 设置l的item为null, 帮助GC\n    l.item = null;\n    // 设置l的prev为null, 帮助GC\n    l.prev = null; // help GC\n    // 修改last指向prev\n    last = prev;\n    // 修改prev节点的next指向null\n    if (prev == null) // 如果链表只有一个元素, 说明被移除后, 队列就是空的, 则first设置为null\n        first = null;\n    else\n        prev.next = null;\n    // 链表大小减一\n    size--;\n    // 数组修改次数加一\n    modCount++;\n    return element;\n}\n```\n\n另外还有实现Queue接口的```#pollLast()```方法，调用的```#unlinkLast(Node<E> f)```方法与上面一致\n\n```java\npublic E pollLast() {\n    final Node<E> l = last;\n    return (l == null) ? null : unlinkLast(l);\n}\n```\n\n### 6.5.移除多个元素\n\n```java.util.AbstractCollection<E>``` 类的 ```#removeAll(Collection<?> c)``` 方法，批量移除指定的多个元素\n\n```java\npublic boolean removeAll(Collection<?> c) {\n    Objects.requireNonNull(c);\n    boolean modified = false;\n    // 获得迭代器\n    Iterator<?> it = iterator();\n    // 通过迭代器遍历\n    while (it.hasNext()) {\n        // 如果c中存在该元素, 则进行移除\n        if (c.contains(it.next())) {\n            it.remove();\n            modified = true; // 标记修改\n        }\n    }\n    return modified;\n}\n```\n\n相反的，```#retainAll(Collection<?> c)``` 求LinkedList与指定集合的交集\n\n```java\npublic boolean retainAll(Collection<?> c) {\n    Objects.requireNonNull(c);\n    boolean modified = false;\n    // 获得迭代器\n    Iterator<E> it = iterator();\n    // 通过迭代器遍历\n    while (it.hasNext()) {\n        // 如果c中不存在该元素, 则进行移除\n        if (!c.contains(it.next())) {\n            it.remove();\n            modified = true;\n        }\n    }\n    return modified;\n}\n```\n\n### 6.6.清空链表\n\n```#clear()``` 方法\n\n```java\npublic void clear() {\n    // Clearing all of the links between nodes is \"unnecessary\", but:\n    // - helps a generational GC if the discarded nodes inhabit\n    //   more than one generation\n    // - is sure to free memory even if there is a reachable Iterator\n    // 顺序遍历链表, 设置每个节点前后指向为null\n    // 通过这样的方式, 帮助GC\n    for (Node<E> x = first; x != null; ) {\n        // 获取下一个节点\n        Node<E> next = x.next;\n        // 设置x的item,next,prev为null\n        x.item = null;\n        x.next = null;\n        x.prev = null;\n        // 设置下一个节点为x\n        x = next;\n    }\n    // 清空first和last的指向\n    first = last = null;\n    // 设置链表大小为0\n    size = 0;\n    // 增加数组修改次数\n    modCount++;\n}\n```\n\n## 7.查找、获取与设定指定元素\n\n### 7.1.查找首个指定元素的位置\n\n```#indexOf(Object o)``` 遍历查找首个为指定元素的位置\n\n```java\npublic int indexOf(Object o) {\n    int index = 0;\n    if (o == null) { // 如果o为null\n        // 顺序遍历, 如果item为null, 进行返回\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null)\n                return index;\n            index++;\n        }\n    } else { // 如果o非null\n        // 顺序遍历, 如果item为o的节点, 进行返回\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item))\n                return index;\n            index++;\n        }\n    }\n    // 未找到\n    return -1;\n}\n```\n\n而 ```#contains(Object o)``` 基于该方法实现\n```java\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n```\n\n### 7.2.查找最后一个指定元素的位置\n\n```#lastIndexOf(Object o)``` 倒序遍历查找最后一个指定元素的位置\n\n```java\npublic int lastIndexOf(Object o) {\n    int index = size;\n    if (o == null) { // o为null\n        // 倒序遍历, 如果item为null, 返回\n        for (Node<E> x = last; x != null; x = x.prev) {\n            index--;\n            if (x.item == null)\n                return index;\n        }\n    } else { // o非null\n        // 倒序遍历, 如果item为o的节点, 返回\n        for (Node<E> x = last; x != null; x = x.prev) {\n            index--;\n            if (o.equals(x.item))\n                return index;\n        }\n    }\n    // 找不到\n    return -1;\n}\n```\n\n### 7.3.获得指定位置的元素\n\n由于 LinkedList 不支持随机访问，所以该方法时间复杂度为 O(n)\n\n```java\npublic E get(int index) {\n    checkElementIndex(index);\n    // 基于node()方法实现, 时间复杂度为O(n)\n    return node(index).item;\n}\n```\n\n因为 LinkedList 实现了 Deque 接口，所以它实现了 ```#peekFirst()``` 和 ```#peekLast()``` 方法，分别获得链表头、尾的元素\n\n```java\npublic E peekFirst() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n }\n\npublic E peekLast() {\n    final Node<E> l = last;\n    return (l == null) ? null : l.item;\n}\n```\n\n因为LinkedList实现了 Queue 接口，所以它实现了 ```#peek()``` , ```#element()``` 方法，获取 LinkedList 的头节点\n\n```java\npublic E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n\npublic E element() { // 如果链表为空, 抛出NoSuchElementException异常\n    return getFirst();\n}\n\npublic E getFirst() {\n    final Node<E> f = first;\n    if (f == null) \n        throw new NoSuchElementException();\n    return f.item;\n}\n```\n\n另外还有 ```#getLast()``` 方法，获取 LinkedList 的尾节点\n\n```java\n\npublic E getLast() {\n    final Node<E> l = last;\n    if (l == null)\n        throw new NoSuchElementException();\n    return l.item;\n}\n\n```\n\n### 7.4.设置指定位置的元素\n\n```#set(int index, E element)``` 方法，设定指定元素到指定位置\n\n```java\npublic E set(int index, E element) {\n    checkElementIndex(index);\n    // 获取第index位置的节点\n    Node<E> x = node(index);\n    // 获取节点原来的值\n    E oldVal = x.item;\n    // 修改对应的值\n    x.item = element;\n    return oldVal;\n}\n```\n\n## 8.序列化与反序列化\n\n### 8.1.序列化\n\n```#writeObject(java.io.ObjectOutputStream s)``` 方法，序列化链表\n\n```java\n@java.io.Serial\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException {\n    // Write out any hidden serialization magic\n    // 写入非静态属性、非transient属性\n    s.defaultWriteObject();\n\n    // Write out size\n    // 写入链表大小\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    // 顺序遍历, 逐个序列化\n    for (Node<E> x = first; x != null; x = x.next)\n        s.writeObject(x.item);\n}\n```\n\n### 8.2.反序列化\n\n```#readObject(java.io.ObjectInputStream s)``` 方法，反序列化\n\n```java\n@SuppressWarnings(\"unchecked\")\n@java.io.Serial\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n    // Read in any hidden serialization magic\n    // 读取非静态属性、非transient属性\n    s.defaultReadObject();\n\n    // Read in size\n    // 读取size\n    int size = s.readInt();\n\n    // Read in all elements in the proper order.\n    // 顺序遍历, 逐个反序列化\n    for (int i = 0; i < size; i++)\n        linkLast((E)s.readObject()); // 添加到链表尾部\n}\n```\n\n## 99.其他常用方法\n\n### 99.1.转换为数组\n\n```#toArray()``` 方法，将 LinkedList 转换为 Object 数组\n\n```java\npublic Object[] toArray() {\n    // 创建Object数组\n    Object[] result = new Object[size];\n    // 顺序遍历节点, 设置到Object数组中\n    int i = 0;\n    for (Node<E> x = first; x != null; x = x.next)\n        result[i++] = x.item;\n    return result;\n}\n```\n\n如果需要指定类型，可以用 ```toArray(T[] a)``` 方法\n\n```\n@SuppressWarnings(\"unchecked\")\npublic <T> T[] toArray(T[] a) {\n    // 如果传入的数组小于size大小, 则直接复制一个新数组\n    if (a.length < size)\n        a = (T[])java.lang.reflect.Array.newInstance(\n                            a.getClass().getComponentType(), size);\n    // 顺序遍历链表, 复制到a中\n    int i = 0;\n    Object[] result = a;\n    for (Node<E> x = first; x != null; x = x.next)\n        result[i++] = x.item;\n\n    // 如果传入的数组大于size大小, 则将size赋值为null\n    if (a.length > size)\n        a[size] = null;\n\n    // 返回a\n    return a;\n}\n```\n\n### 99.2.求哈希值\n\n```java.util.AbstractList<E>``` 类 ```#hashCode()``` 方法\n\n```java\npublic int hashCode() {\n    int hashCode = 1;\n    // 遍历, 求哈希\n    for (E e : this)\n        hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());\n    return hashCode;\n}\n```\n\n### 99.3.判断相等\n\n```java.util.AbstractList<E>``` 类 ```#equals(Object o)``` 方法\n\n```java\npublic boolean equals(Object o) {\n    // 如果o就是自己, 返回true\n    if (o == this)\n        return true;\n    // 如果o不是List, 返回false\n    if (!(o instanceof List))\n        return false;\n\n    // 创建迭代器, 顺序遍历比对\n    ListIterator<E> e1 = listIterator();\n    ListIterator<?> e2 = ((List<?>) o).listIterator();\n    while (e1.hasNext() && e2.hasNext()) {\n        E o1 = e1.next();\n        Object o2 = e2.next();\n        if (!(o1==null ? o2==null : o1.equals(o2))) // 如果不相等, 返回false\n            return false;\n    }\n    // 如果迭代器没有遍历完, 说明两者长度不等, 所以不相等; 否则, 相等\n    return !(e1.hasNext() || e2.hasNext());\n}\n```\n\n### 99.4.克隆\n\n```#clone()``` 方法，克隆LinkedList对象\n\n```java\npublic Object clone() {\n    // 调用父类, 进行克隆\n    LinkedList<E> clone = superClone();\n\n    // Put clone into \"virgin\" state\n    // 重置clone为初始化状态\n    clone.first = clone.last = null;\n    clone.size = 0;\n    clone.modCount = 0;\n\n    // Initialize clone with our elements\n    // 顺序遍历, 逐个添加到clone中\n    for (Node<E> x = first; x != null; x = x.next)\n        clone.add(x.item);\n\n    return clone;\n}\n```","tags":["jdk"]},{"title":"JDK源码阅读笔记——集合Ⅰ数组ArrayList","url":"/2020/04/06/JDK源码阅读笔记——集合I数组ArrayList/","content":"\n> 本JDK源码阅读笔记基于OpenJDK 13 : <https://github.com/openjdk/jdk>\n>\n> 一些可能表述或理解不当，请见谅\n\n## 0.前言\n\n之前跟着[芋道源码](http://www.iocoder.cn/ )的**精尽 JDK 源码解析**看了一遍，过了一个月后发现不做笔记不复习基本都忘光了，于是萌生了搭建一个博客来记录一下笔记，当是给自己挖一个坑吧。\n\n## 1.概述\n\n**ArrayList**  是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。\n\n## 2.类图\n\nArrayList 实现的接口、继承的抽象类，如下图所示：\n\n![ArrayList.jpg](https://i.loli.net/2020/04/06/sczg7m2PW6iIhdn.jpg)\n\n- **java.util.AbstractList**  提供了 List 接口的骨架实现，大幅度的减少了实现**迭代遍历**相关操作的代码。如  ```#iterator()``` 、 ```#indexOf(Object o)``` 等方法\n- **java.util.List** 提供数组的添加、删除、修改、迭代遍历等操作\n- **java.util.RandomAccess** 表示 ArrayList 里的元素可以被高效的随机访问，以下标数字的方式获取元素\n- **java.io.Serialiable** 表示 ArrayList 支持序列化和反序列化操作，具有固定的 serialVersionUID 属性值 \n- **java.lang.Cloneable** 表示 ArrayList 支持调用 Object 的 ```#clone()``` 方法实现拷贝\n\n## 3.属性\n\nArrayList 的属性只有两个：\n\n![02.png](https://i.loli.net/2020/04/06/wGp4x5s7bC2RQdF.png)\n\n- **elementData** 元素数组\n\n- **size** 数组大小。 **size** 代表 ArrayList 已经使用 elementData 的元素的数量，调用 ```#size()``` 方法也是返回该属性大小。并且，当添加新的元素时，恰好其就是元素添加到数组的下标。然而， ArrayList 真正的大小是 **elementData** 的大小。\n\n源码如下：\n\n```java\n   /**\n     *\n     * 元素数组\n     *\n     * 当添加新的元素时，如果该数组容量不足，会创建新数组，并将原数组的元素拷贝到新数组。\n     * 之后，将该变量的内存地址指向该新数组。\n     *\n     * The array buffer into which the elements of the ArrayList are stored.\n     * The capacity of the ArrayList is the length of this array buffer. Any\n     * empty ArrayList with elementData ``` DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n     * will be expanded to DEFAULT_CAPACITY when the first element is added.\n     */\n    transient Object[] elementData; // non-private to simplify nested class access\n\n    /**\n     *\n     * 已使用的数组的大小\n     *\n     * The size of the ArrayList (the number of elements it contains).\n     *\n     * @serial\n     */\n    private int size;\n```\n\n\n## 4.构造方法\n\nArrayList一共有3个构造方法\n\n1. **```#ArrayList(int initialCapacity)```**\n\n根据传入的容量来创建数组，合理使用避免扩容\n```java\n    public ArrayList(int initialCapacity) {\n        // 初始化容量大于0时, 创建Object数组\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        // 初始化容量等于0时, 指向 EMPTY_ELEMENTDATA 对象\n        // 添加元素时, 会进行扩容创建需要的数组\n        } else if (initialCapacity ``` 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        // 初始化容量小于0时, 抛出异常\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n\n2. **```#ArrayList()```**\n\n无参默认构造函数\n\n```java\n/**\n * 无参数构造\n *\n * Constructs an empty list with an initial capacity of ten.\n */\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n```\n3. **```#ArrayList(Collection<? extends E> c)```**\n\n传入 **c** 集合，作为 ArrayList 的 **elementData** 进行初始化\n\n```java\npublic ArrayList(Collection<? extends E> c) {\n    // 将c转换为Object数组\n    elementData = c.toArray();\n    // 如果数组长度大于0\n    if ((size = elementData.length) != 0) {\n        // defend against c.toArray (incorrectly) not returning Object[]\n        // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)\n        // 如果集合元素不是Object[]类型, 则会创建新的Object[], 并将elementData赋值到其中, 最后赋值给elementData\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    // 如果数组长度等于0, 则使用EMPTY_ELEMENTDATA\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n```\n- 附： ArrayList 的三个**常量**\n\n```java\n/**\n * 默认初始化容量\n */\nprivate static final int DEFAULT_CAPACITY = 10;\n/**\n *\n * 共享的空数组对象\n *\n * 在{@link #ArrayList(int)} 或 {@link #ArrayList(Collection)} 构造方法中，\n * 如果传入的初始化大小或者集合大小为0时，将{@link #elementData}指向它\n */\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n/**\n * 共享的空数组对象, 用于{@link #ArrayList()} 构造方法.\n *\n * 通过使用该静态变量, 和{@link #EMPTY_ELEMENTDATA}在第一次添加元素时区分开来\n */\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n```\n- 一般认为在初始化不指定容量时，ArrayList的默认大小为 10 。但实际上是初始化为 ```DEFAULTCAPACITY_EMPTY_ELEMENTDATA``` 这个空数组，原因是考虑到部分场景下， ArrayList 被初始化而实际并未使用。所以，ArrayList初始化时是个空数组，只有添加元素后，才会扩容为容量 10 的数组。\n\n-  ```DEFAULTCAPACITY_EMPTY_ELEMENTDATA``` 首次扩容 10 ，而 ```EMPTY_ELEMENTDATA``` 按照 1.5 倍扩容\n\n## 5.添加元素与扩容\n\n### 5.1.#add(E e)——添加单个元素\n\n  **顺序**添加元素到末尾，若容量不够会先进行扩容\n\n  ```java\n      public boolean add(E e) {\n          // 增加数组修改次数, 父类AbstractList上, 定义了modCount属性, 用于记录数组修改次数\n          modCount++;\n          // 添加元素\n          add(e, elementData, size);\n          // 返回添加成功\n          return true;\n      }\n  \n      private void add(E e, Object[] elementData, int s) {\n          // 如果容量不够, 进行扩容\n          if (s ``` elementData.length)\n              elementData = grow();\n          // 在数组末尾添加元素\n          elementData[s] = e;\n          // 数量加一\n          size = s + 1;\n      }\n  ```\n\n### 5.2.#add(int index, E element) ——插入单个元素到指定位置\n\n  将 index + 1 位置开始的元素往后挪 1 位，再把元素插入到指定位置\n\n  ```java\n      public void add(int index, E element) {\n          // 校验位置是否在数组范围内\n          rangeCheckForAdd(index);\n          // 增加数组修改次数\n          modCount++;\n          // 如果数组大小不足, 进行扩容\n          final int s;\n          Object[] elementData;\n          if ((s = size) ``` (elementData = this.elementData).length)\n              elementData = grow();\n          // 将index+1位置开始的元素往后挪\n          System.arraycopy(elementData, index,\n                           elementData, index + 1,\n                           s - index);\n          // 设置元素到指定的位置\n          elementData[index] = element;\n          // 数组大小加一\n          size = s + 1;\n      }\n  \n      private void rangeCheckForAdd(int index) {\n          if (index > size || index < 0)\n              throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n      }\n  ```\n\n  \n\n### 5.3.#grow()——数组扩容\n\n  当 elementData 容量不足时，会进行扩容。扩容首先创建一个新的更大的数组，一般是 **1.5** 倍大小，然后利用 ```**java.utils.Arrays#copyOf(T[], int)**``` 拷贝原有的数组到新数组，返回新数组\n\n  ```java\n      private Object[] grow() {\n          // 最小需要扩容1\n          return grow(size + 1);\n      }\n  \n      private Object[] grow(int minCapacity) {\n          int oldCapacity = elementData.length;\n          // 如果原容量大于0, 或者数组不是DEFAULTCAPACITY_EMPTY_ELEMENTDATA时, 计算新的数组大小, 并创建扩容\n          if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n              // 计算新的数组大小\n              // 简单来说是Math.max(minGrowth, prefGrowth) + oldLength\n              // 一般情况下, 是1.5倍扩容(>> 1 为右移操作，相当于除以 2). 但是存在两个特殊情况:\n              // 1> 初始化数组要求大小为0时, 此时使用minCapacity传入的1\n              // 2> 添加多个元素时, 传入的minCapacity不再仅仅加1,\n              // 而是扩容到elementData恰好可以添加多个元素, 而该数量可能会超过当前size的1.5倍\n              int newCapacity = ArraysSupport.newLength(oldCapacity,\n                      minCapacity - oldCapacity, /* minimum growth */\n                      oldCapacity >> 1           /* preferred growth */);\n              return elementData = Arrays.copyOf(elementData, newCapacity);\n          // 如果是DEFAULTCAPACITY_EMPTY_ELEMENTDATA数组, 直接创建新的数组\n          } else {\n              return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n          }\n      }\n  ```\n\n### 5.4.#addAll(Collection<? extends E> c)——添加多个元素\n\n  在数组末尾批量添加多个元素，可以避免多次扩容\n\n  ```java\n      public boolean addAll(Collection<? extends E> c) {\n          // 转换成a数组\n          Object[] a = c.toArray();\n          // 增加修改次数\n          modCount++;\n          // 如果a数组大小为0, 返回ArrayList数组无变化\n          int numNew = a.length;\n          if (numNew ``` 0)\n              return false;\n          // 如果elementData数组剩余容量不足, 则进行扩容, 扩至能容纳a数组\n          Object[] elementData;\n          final int s;\n          if (numNew > (elementData = this.elementData).length - (s = size))\n              elementData = grow(s + numNew);\n          // 将a复制到elementData从s开始位置\n          System.arraycopy(a, 0, elementData, s, numNew);\n          // 数组大小加numNew\n          size = s + numNew;\n          return true;\n      }\n  ```\n\n### 5.5.#addAll(int index, Collection<? extends E> c)——从指定位置插入多个元素\n\n  从指定index位置插入多个元素，如果 index 开始的位置已经被占用，则把元素往后挪 c 的长度。 * 号位置是差异点\n\n  ```java\n      public boolean addAll(int index, Collection<? extends E> c) {\n          // 校验范围是否在数组内\n          rangeCheckForAdd(index);\n  \n          // 转换成a数组\n          Object[] a = c.toArray();\n          // 增加修改次数\n          modCount++;\n          // 如果a数组大小为0, 返回ArrayList数组无变化\n          int numNew = a.length;\n          if (numNew ``` 0)\n              return false;\n          // 如果elementData数组剩余容量不足, 则进行扩容, 扩至能容纳a数组\n          Object[] elementData;\n          final int s;\n          if (numNew > (elementData = this.elementData).length - (s = size))\n              elementData = grow(s + numNew);\n  \n          // **如果index开始的位置已经被占用, 将它们后移\n          int numMoved = s - index;\n          if (numMoved > 0)\n              System.arraycopy(elementData, index,\n                               elementData, index + numNew,\n                               numMoved);\n          // 将a复制到elementData从s开始位置\n          System.arraycopy(a, 0, elementData, index, numNew);\n          // 数组大小加numNew\n          size = s + numNew;\n          return true;\n      }\n  ```\n\n### 5.6.#ensureCapacity(int minCapacity)——主动扩容\n\n```java\n    /**\n     *\n     * 保证elementData数组容量至少有minCapacity(主动扩容)\n     */\n    public void ensureCapacity(int minCapacity) {\n        if (minCapacity > elementData.length // 如果minCapacity大于数组的容量\n            && !(elementData ``` DEFAULTCAPACITY_EMPTY_ELEMENTDATA // 如果elementData是DEFAULTCAPACITY_EMPTY_ELEMENTDATA的时候\n                 && minCapacity <= DEFAULT_CAPACITY)) { // 需要最低容量大于DEFAULT_CAPACITY, 因为实际上容量是DEFAULT_CAPACITY\n            // 数组修改次数加一\n            modCount++;\n            // 扩容\n            grow(minCapacity);\n        }\n    }\n```\n\n## 6. 移除元素与缩容\n\n### 6.1.#remove(int index)——移除单个元素\n\n移除指定位置的单个元素，并返回该元素\n\n```java\n    public E remove(int index) {\n        // 校验index不超过size\n        Objects.checkIndex(index, size);\n        final Object[] es = elementData;\n\n        // 记录该位置的原值\n        @SuppressWarnings(\"unchecked\") E oldValue = (E) es[index];\n        // 快速移除\n        fastRemove(es, index);\n\n        // 返回该位置的原值\n        return oldValue;\n    }\n```\n\n### 6.2.#removeRange(int fromIndex, int toIndex)——移除指定区间元素\n\n移除指定区间内多个元素\n\n```java\n    protected void removeRange(int fromIndex, int toIndex) {\n        // 范围不正确, 抛出异常\n        if (fromIndex > toIndex) {\n            throw new IndexOutOfBoundsException(\n                    outOfBoundsMsg(fromIndex, toIndex));\n        }\n        // 修改次数加一\n        modCount++;\n        // 移除[fromIndex, toIndex)的多个元素\n        shiftTailOverGap(elementData, fromIndex, toIndex);\n    }\n\n    private void shiftTailOverGap(Object[] es, int lo, int hi) {\n        // 将es从hi位置开始的元素, 移到lo位置开始\n        System.arraycopy(es, hi, es, lo, size - hi);\n        // 将从[size - hi + lo, size)的元素置空, 因为已经被挪到前面了\n        // i = (size -= hi - lo)更新了size\n        for (int to = size, i = (size -= hi - lo); i < to; i++)\n            es[i] = null;\n    }\n```\n\n### 6.3.#removeAll(Collection<?> c)——移除指定多个元素\n\n```java\n/**\n * 批量移除多个指定元素\n * 通过两个变量w(写入位置)和r(读取位置), 按照r顺序遍历数组elementData\n * 如果不存在于指定的多个元素中, 则写入elementData的w位置, 然后w+1, 跳到下一个写入位置\n * 通过这样的方式, 实现将不存在elementData覆盖写到w位置\n */\npublic boolean removeAll(Collection<?> c) {\n    return batchRemove(c, false, 0, size);\n}\n\n/**\n * complement 参数，翻译过来是“补足”的意思。怎么理解呢？表示如果 elementData 元素在 c 集合中时，是否保留。\n * 如果 complement 为 false 时，表示在集合中，就不保留，这显然符合 #removeAll(Collection<?> c) 方法要移除的意图。\n * 如果 complement 为 true 时，表示在集合中，就暴露，这符合我们后面会看到的 #retainAll(Collection<?> c) 方法要求交集的意图。\n */\nboolean batchRemove(Collection<?> c, boolean complement,\n                    final int from, final int end) {\n    // 校验c非null\n    Objects.requireNonNull(c);\n    final Object[] es = elementData;\n    int r;\n    // Optimize for initial run of survivors\n    // 优化, 顺序遍历elementData数组, 找到第一个不符合complement, 然后结束遍历\n    for (r = from;; r++) {\n        // 遍历到尾, 都没有不符合条件的, 直接返回false\n        if (r ``` end)\n            return false;\n        // 如果包含结果不符合complement时, 结束\n        if (c.contains(es[r]) != complement)\n            break;\n    }\n    // 设置开始写入w为r, 注意不是r++\n    // r++后, 用于读取下一个位置的元素. 因为通过上面的优化, 我们已经知道es[r]是不符合条件的\n    int w = r++;\n    try {\n        // 继续遍历elementData数组, 如果符合条件, 则进行移除\n        for (Object e; r < end; r++)\n            if (c.contains(e = es[r]) ``` complement) // 判断符合条件\n                es[w++] = e; // 移除的方式, 通过将当前值e写入到w位置, 然后w跳到下一个位置\n    } catch (Throwable ex) {\n        // Preserve behavioral compatibility with AbstractCollection,\n        // even if c.contains() throws.\n        // 如果contains方法发生异常, 则将es从r位置的数组写入到es从w开始的位置\n        System.arraycopy(es, r, es, w, end - r);\n        w += end - r;\n        // 抛出异常\n        throw ex;\n    } finally {\n        // 增加数组修改次数\n        modCount += end - w;\n        // 将数组[w, end)位置赋值为null\n        shiftTailOverGap(es, w, end);\n    }\n    return true;\n}\n```\n\n### 6.4.retainAll(Collection<?> c)——求elementData与多个元素交集\n\n一样调用 batchRemove ，区别是传入 true ，即移除不在 c 的元素\n\n```java\npublic boolean retainAll(Collection<?> c) {\n    return batchRemove(c, true, 0, size);\n}\n```\n\n### 6.5.#trimToSize()——缩容\n\n建立与 elementData 同长度的数组，并进行复制\n\n```java\npublic void trimToSize() {\n    // 增加修改次数\n    modCount++;\n    // 如果有多余的空间, 则进行缩容\n    if (size < elementData.length) {\n        elementData = (size ``` 0)\n          ? EMPTY_ELEMENTDATA // 大小为0时, 直接使用EMPTY_ELEMENTDATA\n          : Arrays.copyOf(elementData, size); // 大小大于0时, 则创建大小为size的新数组, 将原数组复制到其中\n    }\n}\n```\n\n## 7.查找、获取与设定元素\n\n### 7.1.#indexOf(Object o)——查找元素\n\n从头开始遍历寻找目标元素\n\n```java\npublic int indexOf(Object o) {\n    return indexOfRange(o, 0, size);\n}\n\nint indexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    // o为null的情况\n    if (o ``` null) {\n        for (int i = start; i < end; i++) {\n            if (es[i] ``` null) {\n                return i;\n            }\n        }\n    // o非null的情况\n    } else {\n        for (int i = start; i < end; i++) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    // 找不到返回-1\n    return -1;\n}\n```\n\n### 7.2.#contains(Object o)——判断是否包含该元素\n\n用上述的<u>#indexOf(Object o)</u>方法实现\n\n```java\npublic boolean contains(Object o) {\n    return indexOf(o) >= 0;\n}\n```\n\n### 7.3.#lastIndexOf(Object o)——查找最后一个指定元素的位置\n\n和 ```#indexOf(Object o)``` 差不多，就是倒序遍历\n\n```java\npublic int lastIndexOf(Object o) {\n    return lastIndexOfRange(o, 0, size);\n}\n\nint lastIndexOfRange(Object o, int start, int end) {\n    Object[] es = elementData;\n    // o为null的情况\n    if (o ``` null) {\n        for (int i = end - 1; i >= start; i--) {\n            if (es[i] ``` null) {\n                return i;\n            }\n        }\n    // o非null的情况\n    } else {\n        for (int i = end - 1; i >= start; i--) {\n            if (o.equals(es[i])) {\n                return i;\n            }\n        }\n    }\n    // 找不到返回-1\n    return -1;\n}\n```\n\n### 7.4.#get(int index)——获取指定位置元素\n\n```java\npublic E get(int index) {\n    // 校验index不超过size\n    Objects.checkIndex(index, size);\n    // 获得index位置的元素--时间复杂度为O(1)\n    return elementData(index);\n}\n```\n\n### 7.5. #set(int index, E element)——在指定位置设定元素\n\n```java\npublic E set(int index, E element) {\n    // 校验index不超过size\n    Objects.checkIndex(index, size);\n    // 获得index位置原来的值\n    E oldValue = elementData(index);\n    // 修改index位置为新值\n    elementData[index] = element;\n    // 返回旧值\n    return oldValue;\n}\n```\n\n## 8.序列化与反序列化\n\n### 8.1.#writeObject(java.io.ObjectOutputStream s)——序列化\n\n elementData 带有关键字 transient ，通常来说不会被序列化。\n\n ArrayList 的序列化是先写入非静态、非 transient 属性，然后再遍历写入 elementData 数据，节省空间和时间\n\n```java\n/**\n *\n * 实现ArrayList数组的序列化\n *\n */\n@java.io.Serial\nprivate void writeObject(java.io.ObjectOutputStream s)\n    throws java.io.IOException {\n    // Write out element count, and any hidden stuff\n    // 获得当前数组的修改次数\n    int expectedModCount = modCount;\n    // 写入非静态属性, 非transient属性\n    s.defaultWriteObject();\n\n    // Write out size as capacity for behavioral compatibility with clone()\n    // 写入size, 主要为了与clone方法兼容\n    s.writeInt(size);\n\n    // Write out all elements in the proper order.\n    // 逐个写入elementData数组的元素\n    // elementData是transient定义的, 并不一定全满, 容量有一定的预留\n    // 直接序列化, 会造成空间的浪费, 所以只序列化[0, size)的元素\n    for (int i=0; i<size; i++) {\n        s.writeObject(elementData[i]);\n    }\n\n    // 如果数组修改次数发生了变化, 抛出异常\n    if (modCount != expectedModCount) {\n        throw new ConcurrentModificationException();\n    }\n}\n```\n\n### 8.2.#readObject(java.io.ObjectInputStream s)——反序列化\n\n反序列化也是一样，先读取非静态、非 transient 属性，然后再逐个读取元素\n\n```java\n@java.io.Serial\nprivate void readObject(java.io.ObjectInputStream s)\n    throws java.io.IOException, ClassNotFoundException {\n\n    // Read in size, and any hidden stuff\n    // 读取非静态、非transient属性\n    s.defaultReadObject();\n\n    // Read in capacity\n    // 读取size, 不过忽略不用\n    s.readInt(); // ignored\n\n    if (size > 0) {\n        // like clone(), allocate array based upon size not capacity\n        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);\n        // 创建elements数组\n        Object[] elements = new Object[size];\n\n        // Read in all elements in the proper order.\n        // 逐个读取\n        for (int i = 0; i < size; i++) {\n            elements[i] = s.readObject();\n        }\n\n        // 赋值给elementData\n        elementData = elements;\n    } else if (size ``` 0) {\n        // 如果size是0, 直接使用空数组\n        elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new java.io.InvalidObjectException(\"Invalid size: \" + size);\n    }\n}\n```\n\n## 99.其他常用方法\n\n### 99.1.#toArray()——转换为数组\n\nArrayList 提供两个方法用于把 List 转换为数组\n\n1. 直接返回 Object 数组\n\n\n```java\npublic Object[] toArray() {\n    return Arrays.copyOf(elementData, size);\n}    \n```\n\n2. 转换成指定类型数组\n\n```java\n@SuppressWarnings(\"unchecked\")\npublic <T> T[] toArray(T[] a) {\n    // 如果传入的数组小于size大小, 则直接复制一个新数组返回\n    if (a.length < size)\n        // Make a new array of a's runtime type, but my contents:\n        return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n    // 将elementData复制到a中\n    System.arraycopy(elementData, 0, a, 0, size);\n    // 如果传入的数组长度大于size, 则将a[size]赋值为null\n    if (a.length > size)\n        a[size] = null;\n    // 返回a\n    return a;\n}\n```\n\n### 99.2.#hashCode()——求哈希值\n\n```java\npublic int hashCode() {\n    // 获取当前数组修改次数\n    int expectedModCount = modCount;\n    // 计算哈希值\n    int hash = hashCodeRange(0, size);\n    // 如果修改次数发生改变, 则抛出ConcurrentModificationException异常\n    checkForComodification(expectedModCount);\n    return hash;\n}\n\nint hashCodeRange(int from, int to) {\n    final Object[] es = elementData;\n    // 如果to超过大小, 则抛出异常\n    if (to > es.length) {\n        throw new ConcurrentModificationException();\n    }\n    // 遍历每个元素, *31求哈希值\n    int hashCode = 1;\n    for (int i = from; i < to; i++) {\n        Object e = es[i];\n        hashCode = 31 * hashCode + (e ``` null ? 0 : e.hashCode());\n    }\n    return hashCode;\n}\n```\n\n### 99.3.#equals(Object o)——判断相等\n\n```java\npublic boolean equals(Object o) {\n    // 如果是自己, 直接返回true\n    if (o ``` this) {\n        return true;\n    }\n\n    // 如果不是List类型, 直接返回false\n    if (!(o instanceof List)) {\n        return false;\n    }\n\n    final int expectedModCount = modCount;\n    // ArrayList can be subclassed and given arbitrary behavior, but we can\n    // still deal with the common case where o is ArrayList precisely\n    // 根据不同类型, 调用不同比对的方法.\n    // 主要考虑ArrayList可以直接使用其elementData属性, 性能更优\n    boolean equal = (o.getClass() ``` ArrayList.class)\n        ? equalsArrayList((ArrayList<?>) o)\n        : equalsRange((List<?>) o, 0, size);\n\n    // 如果修改次数发生改变, 则抛出ConcurrentModificationException异常\n    checkForComodification(expectedModCount);\n    return equal;\n}\n\nboolean equalsRange(List<?> other, int from, int to) {\n    // 如果to大于es的大小, 说明数组发生改变, 抛出异常\n    final Object[] es = elementData;\n    if (to > es.length) {\n        throw new ConcurrentModificationException();\n    }\n    // 通过迭代器遍历other, 然后逐个元素对比\n    var oit = other.iterator();\n    for (; from < to; from++) {\n        // 如果oit没有下一个, 或者元素不相等, 返回false不匹配\n        if (!oit.hasNext() || !Objects.equals(es[from], oit.next())) {\n            return false;\n        }\n    }\n    // 通过oit是否遍历完, 实现大小是否相等效果\n    return !oit.hasNext();\n}\n\nprivate boolean equalsArrayList(ArrayList<?> other) {\n    // 获得other数组的修改次数\n    final int otherModCount = other.modCount;\n    final int s = size;\n    boolean equal;\n    // 判断数组大小是否相等\n    if (equal = (s ``` other.size)) {\n        final Object[] otherEs = other.elementData;\n        final Object[] es = elementData;\n        // 如果s大于es或者otherEs的长度, 说明发生变化, 抛出异常\n        if (s > es.length || s > otherEs.length) {\n            throw new ConcurrentModificationException();\n        }\n        // 遍历, 逐个比较每个元素是否相等\n        for (int i = 0; i < s; i++) {\n            if (!Objects.equals(es[i], otherEs[i])) {\n                equal = false;\n                break; // 如果不相等, break\n            }\n        }\n    }\n    // 如果other修改次数发生变化, 则抛出ConcurrentModificationException异常\n    other.checkForComodification(otherModCount);\n    return equal;\n}\n```\n\n### 99.4.#clear()——清空数组\n\n```java\npublic void clear() {\n    // 增加数组修改次数\n    modCount++;\n    // 遍历数组, 倒序设置为null\n    final Object[] es = elementData;\n    for (int to = size, i = size = 0; i < to; i++)\n        es[i] = null;\n}\n```\n\n### 99.5.#clone()——克隆\n\n```java\npublic Object clone() {\n    try {\n        // 调用父类, 进行克隆\n        ArrayList<?> v = (ArrayList<?>) super.clone();\n        // 拷贝一个新的数组\n        v.elementData = Arrays.copyOf(elementData, size);\n        // 设置新数组修改次数为0\n        v.modCount = 0;\n        return v;\n    } catch (CloneNotSupportedException e) {\n        // this shouldn't happen, since we are Cloneable\n        throw new InternalError(e);\n    }\n}\n```\n\n### 99.6.#subList(int fromIndex, int toIndex)——创建子数组\n\n```java\n/**\n * SubList 不是一个只读数组，而是和根数组 root 共享相同的 elementData 数组，\n * 只是说限制了 [fromIndex, toIndex) 的范围\n *\n */\npublic List<E> subList(int fromIndex, int toIndex) {\n    subListRangeCheck(fromIndex, toIndex, size);\n    return new SubList<>(this, fromIndex, toIndex);\n}\n\nprivate static class SubList<E> extends AbstractList<E> implements RandomAccess {\n    /**\n     * 根ArrayList\n     */\n    private final ArrayList<E> root;\n    /**\n     * 父SubList\n     */\n    private final SubList<E> parent;\n    /**\n     * 起始位置\n     */\n    private final int offset;\n    /**\n     * 大小\n     */\n    private int size;\n    \n    //.......略\n```","tags":["jdk"]},{"title":"心血来潮的博客","url":"/2020/04/03/心血来潮的博客/","content":"\n突然觉得还是搭一个Blog来记录和总结一下看过的学过的东西，或许也坚持不了多久。\n\n<p align=\"right\">04.03.2020</p>","tags":["life"]}]